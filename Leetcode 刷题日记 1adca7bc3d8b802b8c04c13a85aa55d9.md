# Leetcode åˆ·é¢˜æ—¥è®°

## 3.5 (ä¿©æ•°ä¹‹å’Œ)

ä¿©æ•°ä¹‹å’Œ, å“ˆå¸Œè¡¨, æ²¡æƒ³åˆ°çš„æ˜¯, å“ˆå¸Œè¡¨åœ¨pythoné‡Œå°±æ˜¯å­—å…¸

è¿™ä¸ªBç«™çš„å¯è§†åŒ–åŠ¨ç”»è®²çš„è¶…çº§æ˜ç™½ğŸ«¡

[æ•£åˆ—è¡¨(å“ˆå¸Œè¡¨) - æ•£åˆ—å‡½æ•°, å†²çªå¤„ç†, å¹³å‡æŸ¥æ‰¾é•¿åº¦(ASL)_å“”å“©å“”å“©_bilibili](https://www.bilibili.com/video/BV13NwveLE1D?spm_id_from=333.788.videopod.sections&vd_source=fab1ef87b734b1a34847f798d42e2604)

```python
# åˆ›å»ºç©ºå­—å…¸, æˆ‘ä¸€åº¦å†™å‡º haxi = dict{} ğŸ˜‚, è®°å¾—æ”¾åœ¨å¾ªç¯å¤– !!!
haxi = {} 

# å¾€å­—å…¸é‡ŒåŠ å…¥ é”®å€¼å¯¹
haxi[é”®] = å€¼    (ä¿©æ•°ä¹‹å’Œ, é”®æ˜¯æ•°å­—æœ¬èº«, å€¼æ˜¯å¯¹åº”ä¸‹æ ‡)

# åªéœ€è¦éå†ä¸€éç»™å®šæ•°ç»„, æ—¶é—´å¤æ‚åº¦O(n)
# ç©ºé—´å¤æ‚åº¦ï¼šO(n)ã€‚å“ˆå¸Œè¡¨éœ€è¦ O(n) çš„ç©ºé—´ã€‚

# pythonçš„å­—å…¸æŸ¥æ‰¾åº”è¯¥åº•å±‚å°±æ˜¯å“ˆå¸Œè¡¨å®ç°çš„, ä»è€Œå®ç°å¿«é€ŸæŸ¥æ‰¾, æ’å…¥å’Œåˆ é™¤
# (æ‰¾ä¸€ä¸ªæ•°ç”¨å“ˆå¸Œè¡¨ -> æŸ¥æ‰¾éœ€æ±‚)

if target - nums[i] not in haxi: 
# è¿™é‡Œå­—å…¸å¯ä»¥ç›´æ¥æ”¯æŒæŸ¥æ‰¾æ˜¯å¦åœ¨å­—å…¸é‡Œæ˜¯å¦æœ‰æŸä¸ªé”®(åº•å±‚å°±æ˜¯å“ˆå¸Œè¡¨å®ç°)
		haxi[nums[i]] = i
    continue # è·³å‡ºæœ¬æ¬¡å¾ªç¯çš„éå†, ç›´æ¥è¿›å…¥ä¸‹ä¸€æ¬¡)
```

> **å“ˆå¸Œè¡¨çš„æ ¸å¿ƒç‰¹æ€§**ï¼š
> 
> - **é”®å€¼å¯¹å­˜å‚¨**ï¼šå“ˆå¸Œè¡¨é€šè¿‡é”®ï¼ˆkeyï¼‰æ¥å­˜å‚¨å’ŒæŸ¥æ‰¾å€¼ï¼ˆvalueï¼‰ã€‚
> - **å“ˆå¸Œå‡½æ•°**ï¼šå“ˆå¸Œå‡½æ•°å°†é”®æ˜ å°„åˆ°ä¸€ä¸ªå›ºå®šèŒƒå›´çš„ç´¢å¼•ï¼Œç”¨äºç¡®å®šå€¼çš„å­˜å‚¨ä½ç½®ã€‚
> - **å†²çªè§£å†³**ï¼šå½“ä¸åŒçš„é”®æ˜ å°„åˆ°åŒä¸€ä¸ªç´¢å¼•æ—¶ï¼Œéœ€è¦é€šè¿‡å†²çªè§£å†³æ–¹æ³•ï¼ˆå¦‚é“¾åœ°å€æ³•æˆ–å¼€æ”¾å¯»å€æ³•ï¼‰æ¥å¤„ç†ã€‚

---

## 3.6 (æ²¡åˆ·)

- å¤ªç´¯äº†, ä»Šæ—¥æ²¡åˆ·

---

## 3.7 (å­—æ¯å¼‚ä½è¯ & æœ€é•¿è¿ç»­åºåˆ—)

- **`sorted()`** æ˜¯ä¸€ä¸ªå†…ç½®å‡½æ•°ï¼Œå®ƒæ¥å—ä¸€ä¸ªå¯è¿­ä»£å¯¹è±¡ï¼ˆå¦‚å­—ç¬¦ä¸²ã€åˆ—è¡¨ç­‰ï¼‰ï¼Œå¹¶è¿”å›ä¸€ä¸ªåŒ…å«è¯¥å¯è¿­ä»£å¯¹è±¡å…ƒç´ çš„æ’åºååˆ—è¡¨, sorted()
- **`join()`** æ˜¯å­—ç¬¦ä¸²çš„ä¸€ä¸ªæ–¹æ³•ï¼Œå®ƒå°†ä¸€ä¸ªå¯è¿­ä»£å¯¹è±¡ä¸­çš„å…ƒç´ è¿æ¥æˆä¸€ä¸ªå­—ç¬¦ä¸²ã€‚`join()` çš„è¯­æ³•æ˜¯ `str.join(iterable)`ï¼Œå…¶ä¸­ `str` æ˜¯è¿æ¥å…ƒç´ æ—¶ä½¿ç”¨çš„åˆ†éš”ç¬¦ï¼Œ`iterable` æ˜¯è¦è¿æ¥çš„å…ƒç´ åˆ—è¡¨ã€‚åœ¨ `''.join(sorted(s))` ä¸­ï¼Œåˆ†éš”ç¬¦æ˜¯ç©ºå­—ç¬¦ä¸² `''`ï¼Œè¿™æ„å‘³ç€æ’åºåçš„å­—ç¬¦å°†è¢«ç›´æ¥è¿æ¥åœ¨ä¸€èµ·ï¼Œæ²¡æœ‰ä»»ä½•åˆ†éš”ç¬¦.
- å­—æ¯å¼‚ä½è¯
    
    ```python
    for i in haxi:
        print(i)# è¾“å‡ºçš„æ˜¯å­—å…¸çš„é”®
    
    # è¿”å›å­—å…¸çš„å€¼ï¼Œä¸ä½¿ç”¨ list() è½¬æ¢
    values_view = haxi.values()
    print(values_view)  
    # è¾“å‡º: dict_values([('aet', ['eat', 'tea', 'ate']), ('ant', ['tan', 'nat']), ('abt', ['bat'])])   
        
    for value in haxi.values():
        print(value)  # è¾“å‡ºçš„æ˜¯å­—å…¸çš„å€¼
        
    # ['eat', 'tea', 'ate']
    # ['tan', 'nat']
    # ['bat'] 
    
    values_list = list(haxi.values())
    print(values_list)  # è¾“å‡º: [['eat', 'tea', 'ate'], ['tan', 'nat'], ['bat']]
     
    for key, value in haxi.items():
        print(f"é”®: {key}, å€¼: {value}")  # è¾“å‡ºé”®å’Œå¯¹åº”çš„å€¼
        
        
    haxi = {
        'aet': ['eat', 'tea', 'ate'],
        'ant': ['tan', 'nat'],
        'abt': ['bat']
    }
    ```
    
- æœ€é•¿è¿ç»­åºåˆ—
    
    ```python
        # æˆ‘ä¸ªäººè®¤ä¸ºéå¸¸ä¼˜é›…çš„è§£å†³æœ€é•¿è¿ç»­åºåˆ—é—®é¢˜çš„solution, very beautiful!
        # å¦å¤–ä¸€ç§æ ‡å‡†è§£, æ˜¯éå†ä¸€æ¬¡, æ‰¾å½“å‰æ•°çš„æ•°-1, å¦‚æœexist, å°±é©¬ä¸Šä¸‹ä¸€ä¸ª, è¿™é‡Œéƒ½æ˜¯O(1)çš„æ—¶é—´å¤æ‚åº¦, è¯´ç™½äº†, å°±æ˜¯åªæœ‰ æ•°å­—-1 åé¢æ²¡æœ‰çš„, é‚£ä¸ªæ‰èƒ½ä½œä¸ºmaxè¿ç»­åºåˆ—çš„start, ç„¶åå†å¼€å§‹ä¸€æ­¥æ­¥æŸ¥æ‰¾ä¸‹ä¸€ä¸ª, å¾—åˆ°ä¸€ä¸ªé•¿åº¦, å­˜åœ¨maxé‡Œ, ç„¶åå¯ä»¥åšåˆ°ç±»ä¼¼O(1) + O(1) + ... + O(n), å†³å®šä¸ä¼šæ˜¯O(n^2)
        s=set(nums)
        ans = 0
        while s:
            t=1
            #éšä¾¿ä»é›†åˆä¸­æ‹¿å‡ºä¸€ä¸ª
            b=s.pop()
            c=b+1
            a=b-1
            #ä¸€ç›´å‘å³æ¢æµ‹ï¼Œæœ‰t å°±åŠ 1 ï¼Œç„¶åä»é›†åˆä¸­å»é™¤å®ƒï¼Œé›†åˆå˜å°
            while c in s:
                t+=1
                s.remove(c)
                c+=1
            #å‘å·¦æ¢æµ‹
            while a in s:
                t+=1
                s.remove(a)
                a-=1
    
            if t>ans:
                ans=t
    
        return ans
    ```
    

---

## 3.8 (ç§»åŠ¨é›¶+ç››æœ€å¤šæ°´å®¹å™¨)

- ç§»åŠ¨é›¶, å‘ƒå¿«æ…¢æŒ‡é’ˆ, äº¤æ¢é›¶å’Œéé›¶, å·®ä¸å¤šè¿™æ ·çš„æ€è·¯
- æœ€å¤šæ°´
    - æœ€å¤§å­˜æ°´, æ€è·¯æ˜¯1. é¢ç§¯æ˜¯ä¿©æ®µçš„miné«˜åº¦* å®½åº¦; é‚£ä¹ˆæ¯æ¬¡å®½åº¦çš„å‡å°‘(æŒ‡é’ˆçš„ç§»åŠ¨), å¦‚æœé«˜åº¦ä¸èƒ½æ‰¾åˆ°æ¯”ä¹‹å‰æ›´é«˜çš„, é‚£ä¹ˆé¢ç§¯è‚¯å®šæ¯”åŸå…ˆçš„å°; æ‰€ä»¥æ¯æ¬¡ç§»åŠ¨éƒ½æ˜¯ç§»åŠ¨å¯¹åº”æŒ‡é’ˆ é«˜åº¦å°çš„, why? because, ä½ ç§»åŠ¨é«˜åº¦é«˜çš„, å°±ç®—æƒ…å†µå¥½, é«˜äº†, ä½ çš„é¢ç§¯è¿˜æ˜¯å—é™äºminè¾¹, å®½åº¦å‡å°‘, miné«˜åº¦ä¸å˜, é¢ç§¯é“å˜å°, æ‰€ä»¥å¿…é¡»ç§»åŠ¨ä¿©æ®µçš„minè¾¹, æ‰¾åˆ°é«˜åº¦å¢åŠ çš„, åœä¸‹æ¥, ç®—é¢ç§¯, æ¯”è¾ƒé¢ç§¯, åªæœ‰æ¯”åŸå…ˆé«˜, é¢ç§¯æ‰æœ‰å¯èƒ½å¤§; æ¯•ç«Ÿå®½åº¦éƒ½ä¸æ–­å‡å°äº†, é«˜åº¦å¦‚æœè¿˜æ¯”åŸå…ˆå°æ˜¯è‚¯å®šä¸è¡Œçš„
    
    ```python
    class Solution:
        def maxArea(self, height: List[int]) -> int:
            i = 0 
            j = len(height) -1
            s =  (j-i) * min(height[i], height[j])
            tp = 0 
            while i < j:
                if height[i] <= height[j]:
                    while height[i] >= height[i+1] and i+1<j:
    		                 i+=1 
                     # è¿™é‡Œæ³¨æ„å®¤i+1 <j, ä¸è¦å†™i< j
                     # å› ä¸ºå·¦è¾¹æ˜¯ if iåˆ°äº† i+1 å°±æ˜¯j çš„è¯, è¯´æ˜å®½åº¦åªæœ‰ä¸€æ ¼äº†, 
                     # iä¹Ÿä¸ç”¨å»æ‰¾æ¯”è‡ªå·±é«˜çš„ä¸‹ä¸€ä¸ªé«˜åº¦äº†(å°±å·²ç»åˆ°jäº†, ä¸‹ä¸€ä¸ªå°±æ˜¯j,
                     # æ‰€ä»¥è·³å‡ºwhile, ç„¶åi+=1,  
                     # è¯´æ˜æ‰¾ä¸åˆ°æ›´å¤§çš„é«˜åº¦äº†æ¥å¢åŠ é¢ç§¯äº†; 
                     # è¿™æ ·è®©å¤–é¢å¤§while, ä¹Ÿè·³å‡ºå»äº†,ä¹Ÿå°±å¯ä»¥ç»“æŸäº†      
                    i+=1
                else:
                    while height[j] >= height[j-1] and i+1<j:
                        j-=1   
                    j-=1
                    
    	          tp = (j-i) * min(height[i], height[j])
                s = max (s, tp)
                
            return s
    ```
    

---

## 3.9 (ä¸‰æ•°å’Œ)

- èµ·æ¥å°±æ¥ä¸€é“åŠ›æ‰£é¢˜, æ²¡æƒ³åˆ°æ­£å¥½åˆ°ä¸‰æ•°å’Œ
    
    **ä¸‰æ•°ä¹‹å’Œ**æ˜¯ä¸€ä¸ªç»å…¸çš„ç®—æ³•é—®é¢˜ï¼Œé€šå¸¸æè¿°ä¸ºï¼šç»™å®šä¸€ä¸ªåŒ…å«Â `n`Â ä¸ªæ•´æ•°çš„æ•°ç»„Â `nums`ï¼Œåˆ¤æ–­å…¶ä¸­æ˜¯å¦å­˜åœ¨ä¸‰ä¸ªå…ƒç´ Â `a, b, c`ï¼Œä½¿å¾—Â `a + b + c = 0`ï¼Ÿæ‰¾å‡ºæ‰€æœ‰æ»¡è¶³æ¡ä»¶ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„ã€‚
    
    ä»¥ä¸‹æ˜¯è§£å†³è¯¥é—®é¢˜çš„è¯¦ç»†æ€è·¯å’Œä»£ç å®ç°ï¼š
    
    ---
    
    ### 1.Â **é—®é¢˜åˆ†æ**
    
    - **è¾“å…¥**ï¼šä¸€ä¸ªæ•´æ•°æ•°ç»„Â `nums`ã€‚
    - **è¾“å‡º**ï¼šæ‰€æœ‰æ»¡è¶³Â `a + b + c = 0`Â ä¸”ä¸é‡å¤çš„ä¸‰å…ƒç»„Â `[a, b, c]`ã€‚
    - **è¦æ±‚**ï¼š
        - ä¸‰å…ƒç»„ä¸èƒ½é‡å¤ï¼ˆä¾‹å¦‚Â `[-1, 0, 1]`Â å’ŒÂ `[0, 1, -1]`Â æ˜¯é‡å¤çš„ï¼‰ã€‚
        - æ—¶é—´å¤æ‚åº¦å°½é‡ä½ã€‚
    
    ---
    
    ### 2.Â **è§£é¢˜æ€è·¯**
    
    ### (1)Â **æš´åŠ›è§£æ³•ï¼ˆä¸æ¨èï¼‰**
    
    - ä½¿ç”¨ä¸‰é‡å¾ªç¯æšä¸¾æ‰€æœ‰å¯èƒ½çš„ä¸‰å…ƒç»„ï¼Œæ£€æŸ¥æ˜¯å¦æ»¡è¶³Â `a + b + c = 0`ã€‚
    - æ—¶é—´å¤æ‚åº¦ï¼š`O(n^3)`ï¼Œæ•ˆç‡å¤ªä½ã€‚
    
    ### (2)Â **æ’åº + åŒæŒ‡é’ˆï¼ˆæ¨èï¼‰**
    
    - **æ­¥éª¤**ï¼š
        1. **æ’åº**ï¼šå°†æ•°ç»„æ’åºï¼Œæ–¹ä¾¿åç»­æ“ä½œã€‚
        2. **å›ºå®šä¸€ä¸ªæ•°**ï¼šéå†æ•°ç»„ï¼Œå›ºå®šä¸€ä¸ªæ•°Â `nums[i]`Â ä½œä¸ºä¸‰å…ƒç»„çš„ç¬¬ä¸€ä¸ªæ•°ã€‚
        3. **åŒæŒ‡é’ˆæŸ¥æ‰¾**ï¼š
            - ä½¿ç”¨åŒæŒ‡é’ˆÂ `left`Â å’ŒÂ `right`ï¼Œåˆ†åˆ«æŒ‡å‘Â `i+1`Â å’ŒÂ `n-1`ã€‚
            - è®¡ç®—Â `sum = nums[i] + nums[left] + nums[right]`ã€‚
            - å¦‚æœÂ `sum == 0`ï¼Œè®°å½•ä¸‰å…ƒç»„ï¼Œå¹¶ç§»åŠ¨æŒ‡é’ˆå»é‡ã€‚
            - å¦‚æœÂ `sum < 0`ï¼Œè¯´æ˜éœ€è¦æ›´å¤§çš„æ•°ï¼Œ`left++`ã€‚
            - å¦‚æœÂ `sum > 0`ï¼Œè¯´æ˜éœ€è¦æ›´å°çš„æ•°ï¼Œ`right--`ã€‚
        4. **å»é‡**ï¼š
            - åœ¨éå†è¿‡ç¨‹ä¸­ï¼Œè·³è¿‡é‡å¤çš„Â `nums[i]`ã€`nums[left]`Â å’ŒÂ `nums[right]`ã€‚
    - **æ—¶é—´å¤æ‚åº¦**ï¼š`O(n^2)`ï¼ˆæ’åºÂ `O(nlogn)`Â + åŒæŒ‡é’ˆÂ `O(n^2)`ï¼‰ã€‚
    
    ---
    
    ### 3.Â **ä»£ç å®ç°**
    
    ä»¥ä¸‹æ˜¯ Python å®ç°ï¼š
    
    python
    
    å¤åˆ¶
    
    ```python
    def threeSum(nums):
        # ç»“æœåˆ—è¡¨
        result = []
        n = len(nums)
        # å…ˆå¯¹æ•°ç»„æ’åº
        nums.sort()
    
        # éå†æ•°ç»„ï¼Œå›ºå®šç¬¬ä¸€ä¸ªæ•°
        for i in range(n - 2):
            # è·³è¿‡é‡å¤çš„ nums[i]
            if i > 0 and nums[i] == nums[i - 1]:
                continue
            # åŒæŒ‡é’ˆåˆå§‹åŒ–
            left, right = i + 1, n - 1
            while left < right:
                total = nums[i] + nums[left] + nums[right]
                if total == 0:
                    # æ‰¾åˆ°æ»¡è¶³æ¡ä»¶çš„ä¸‰å…ƒç»„
                    result.append([nums[i], nums[left], nums[right]])
                    # è·³è¿‡é‡å¤çš„ nums[left] å’Œ nums[right]
                    while left < right and nums[left] == nums[left + 1]:
                        left += 1
                    while left < right and nums[right] == nums[right - 1]:
                        right -= 1
                    # ç§»åŠ¨æŒ‡é’ˆ
                    left += 1
                    right -= 1
                elif total < 0:
                    # éœ€è¦æ›´å¤§çš„æ•°
                    left += 1
                else:
                    # éœ€è¦æ›´å°çš„æ•°
                    right -= 1
        return result
    ```
    
    ```python
    # æˆ‘è‡ªå·±å†åŠ›æ‰£ä¸Šåˆ·åˆ°, å†™çš„
    class Solution:
        def threeSum(self, nums: List[int]) -> List[List[int]]:
            nums = sorted(nums)
            pivot =0
            ans = []
            while nums[pivot] <=0 and pivot <= len(nums)-3:
                if nums[pivot] == nums[pivot-1] and pivot >0:   # è¿™é‡Œæ²¡æƒ³åˆ°
                    pivot+=1
                    continue
    
                left = pivot +1
                right = len(nums) -1
                while left < right:
                    total = nums[pivot] + nums[left] + nums[right]
                    if total < 0:
                        left +=1
                    if total > 0:
                        right -=1
                    if total == 0:
                        c = [nums[pivot], nums[left], nums[right]]
                        while nums[left+1] == nums[left] and left+1 < right:
                        # è¿™é‡Œçš„left+1 < right 
                            left +=1
                        while nums[right-1] == nums[right] and left+1 < right:
                            right -=1
    
                        left +=1
                        right -=1
                        ans.append(c)
                        
                pivot +=1 # è¿™é‡Œå¿˜è®°å†™äº†
            return ans
    ```
    

---

## 3.10 (æ¥é›¨æ°´)

- æ€è·¯æ²¡ä»€ä¹ˆé—®é¢˜, è¿˜æ˜¯python çš„ä¸€äº›åŸºæœ¬æ“ä½œä¸ç†Ÿæ‚‰, `for i in range(len(height)-2, 0,-1):` , æ³¨æ„python é»˜è®¤æ­¥é•¿ä¸º1
    
    ```python
    class Solution:
        def trap(self, height: List[int]) -> int:
            tmp = 0
            #ä¸€å¼€å§‹æˆ‘è¿˜ä¸çŸ¥é“å¦‚ä½•åˆ›å»ºä¸ ç»™å®šæ•°ç»„é•¿åº¦ç›¸åŒçš„é›¶æ•°ç»„, 
            # å‚»å‚»çš„å†™äº†ä¸€ä¸ªLeft = []
            # åé¢ç»§ç»­Left[ä¸‹æ ‡] -> ç›´æ¥æŠ¥é”™
            Left = [0] * len(height)
            
            for i in range(1, len(height)-1):
                tmp = max(tmp, height[i-1])
                Left[i] = tmp
            
            tmp = 0
            Right = [0] * len(height)
            # ä¸€å¼€å§‹æˆ‘å†™çš„æ˜¯range(len(height)-2, 0), python é»˜è®¤æ­¥é•¿ä¸º1 ..., æ²¡å†™-1 
            # ç­‰äºä»€ä¹ˆéƒ½æ²¡æ‰§è¡Œ
            for i in range(len(height)-2, 0,-1):
                tmp = max(tmp, height[i+1])
                Right[i] = tmp   
    
            ans =0
            for i in range(1, len(height)-1):
                if min(Left[i], Right[i]) - height[i] >0: 
                    ans += min(Left[i], Right[i]) - height[i]
    
            return ans
    
    ```
    

---

## 3.11 (æœ‰æ•ˆæœçš„æ‹¬å· + æœ€å°æ ˆ)

- ä½¿ç”¨æ•°ç»„å®ç°çš„æ ˆç§°ä¸ºé¡ºåºæ ˆã€‚åœ¨é¡ºåºæ ˆä¸­ï¼Œæ ˆåº•é€šå¸¸å›ºå®šåœ¨æ•°ç»„çš„ä¸€ç«¯ï¼Œæ ˆé¡¶æŒ‡é’ˆæŒ‡ç¤ºä¸‹ä¸€ä¸ªå¯ç”¨ä½ç½®ã€‚å½“æ ˆé¡¶æŒ‡é’ˆè¾¾åˆ°æ•°ç»„çš„æœ«å°¾æ—¶ï¼Œæ ˆæ»¡ï¼Œæ— æ³•å†è¿›è¡Œå…¥æ ˆæ“ä½œ
- æœ‰æ•ˆæœçš„æ‹¬å·
    
    ```python
    class Solution:
        def isValid(self, s: str) -> bool:
            dic = {")":"(","]":"[","}":"{"}
            stack = []
            for i in s:
                if i in dic:
                    if stack:
                        if stack[-1] == dic[i]:
                        #æ•²æ‰æœ€åä¸€ä¸ªå…ƒç´ , ç›¸å½“äºå‡ºæ ˆ
                            stack.pop()
                        else:
                            return False
                    else:
                        return False
                else:
                    stack.append(i)
            
            return not stack
            #é¦–å…ˆæ˜ç™½åœ¨Pythonä¸­ï¼Œ
            # Noneã€Falseã€ç©ºå­—ç¬¦ä¸²""ã€0ã€ç©ºåˆ—è¡¨[]ã€ç©ºå­—å…¸{}ã€ç©ºå…ƒç»„()éƒ½ç›¸å½“äºFalse
            # å†™return stack , è¿”å›çš„æ˜¯æ•´ä¸ªæ•°ç»„äº†
            
    ```
    
- æœ€å°æ ˆ
    
    çœ‹åˆ°è¯„è®ºè¯´, å­—èŠ‚ä¸€é¢è¦æ±‚ç”¨O(1)çš„è¾…åŠ©ç©ºé—´, ä¸æ„§æ˜¯ç®—æ³•å‚, å¸¸ç”¨çš„è§£æ³•æ˜¯ç»´æŠ¤ä¸€æ¡æ ˆ, è¾…åŠ©ç©ºé—´å¤æ‚åº¦æ˜¯O(n), å¦‚æœèƒ½å»ç»´æŠ¤ä¸€ä¸ªæ ˆ, æ¯æ¬¡pushè¿›ä¸€ä¸ªæ•°å­—, å¦å¤–ä¸€ä¸ªæ ˆåŒæ­¥pushæœ€æ–°çš„min, æ‰€ä»¥åŒæ­¥çš„æœ‰ä¸€ä¸ªæ ˆ æ¯ä¸ªä½ç½®å¯¹åº”è®°å½•åŸæ ˆçš„åœ¨æ­¤ä½ç½®æ˜¯top æ—¶å€™çš„æ•´ä½“min, è¿™æ ·å¯ä»¥åšåˆ°getMin O(1)æ—¶é—´å¤æ‚åº¦
    
    æœ‰æ²¡æœ‰ä»€ä¹ˆåŠæ³•, èƒ½å°†æ•´ä¸ªO(n)ç©ºé—´çš„æ ˆ, å»æ‰
    å¾ˆå·§å¦™çš„æ–¹æ³•æ˜¯, æ ˆé‡Œçš„æ¯ä¸ªå…ƒç´ è®°å½•çš„æ˜¯,åŠ è¿›å»çš„æ—¶å€™, å’Œmin çš„æ¯”è¾ƒ, ç»Ÿä¸€ä¸º val - min
    
    å¦‚æœæ˜¯<0,  å°±æŠŠåŸæ¥çš„min updateæˆåŠ å…¥çš„å…ƒç´ , æ¯æ¬¡å‡ºæ ˆ, if>0,ç›´æ¥å‡º, å¯¹min ä¸å½±å“, if<0, æŠŠmin modifyå› æ²¡åŠ å…¥å‰çš„(min - stack[-1]),
    
    è¿™æ ·å°±èƒ½åšåˆ°åªç”¨é¢å¤–O(1) çš„è¾…åŠ©ç©ºé—´å¤æ‚åº¦äº†! å› ä¸ºæ ˆé‡Œé¢å­˜çš„ä¸æ˜¯è‡ªå·±, è€Œæ˜¯å’Œmin çš„å…³ç³», çœæ‰äº†å¦å¤–å¼€ä¸€ä¸ªæ ˆå»ç»´æŠ¤n ä¸ª æœ€å°å€¼çš„ç©ºé—´
    
    ```python
    class MinStack:
    
        def __init__(self):
            self.stack = []  
            # if è¦æ±‚è¾…åŠ©ç©ºé—´O(1), è¦å»ç»´æŠ¤
            # new - åŸmin = è¦å­˜çš„æ•°
            self.min = None
    
        def push(self, val: int) -> None:
            if self.stack:
                self.stack.append(val - self.min)
                if val < self.min:
                    self.min = val
            else:
    	        # æ³¨æ„å¯¹ç©ºæ ˆçš„æ“ä½œ!!! ä¹‹å‰å› ä¸ºè¿™ä¸ªåœ°æ–¹é€šè¿‡
                self.stack.append(0)
                self.min = val
            
        def pop(self) -> None:
            if self.stack[-1] <0:
                self.min = self.min - self.stack[-1]
            self.stack.pop()
            
    
        def top(self) -> int:
            if self.stack[-1] < 0:
                return self.min
            else:
                return self.stack[-1] + self.min
    
        def getMin(self) -> int:
            return self.min
    ```
    

---

## 3.12 (å­—ç¬¦ä¸²è§£ç )

- åˆ—è¡¨ [1, 2, 3] â†’ â€œ123â€ , ä¸èƒ½ç”¨str(), ç”¨str  çš„ç»“æœæ˜¯ â€œ[1, 2, 3]â€  ğŸ˜‚
- `str.isdigit()` æ–¹æ³•ç”¨äºæ£€æŸ¥å­—ç¬¦ä¸²ä¸­çš„å­—ç¬¦æ˜¯å¦éƒ½æ˜¯æ•°å­—å­—ç¬¦ã€‚å¯¹äºå•ä¸ªå­—ç¬¦çš„å­—ç¬¦ä¸²ï¼Œå®ƒå¯ä»¥ç”¨æ¥åˆ¤æ–­è¯¥å­—ç¬¦æ˜¯å¦æ˜¯æ•°å­—ã€‚
    
    ```python
    s = "a1b2c3"
    for char in s:
        if char.isdigit():
            print(f"'{char}' æ˜¯æ•°å­—")
        else:
            print(f"'{char}' ä¸æ˜¯æ•°å­—")
    ```
    
    ```
    'a' ä¸æ˜¯æ•°å­—
    '1' æ˜¯æ•°å­—
    'b' ä¸æ˜¯æ•°å­—
    '2' æ˜¯æ•°å­—
    'c' ä¸æ˜¯æ•°å­—
    '3' æ˜¯æ•°å­—
    ```
    
- å­—ç¬¦ä¸²è§£ç , çœ‹è§æ‹¬å·æœ‰å…³çš„è¿™ç§, ä¼˜å…ˆæƒ³åˆ°æ ˆ, å€Ÿé‰´äº†é¢˜è§£, è¿˜æ˜¯å‚è€ƒäº†åˆ«äººçš„code; ç„¶åå°±æ˜¯è¿™é‡Œçš„ä¸€äº›list()çš„ç”¨æ³•, + ç›´æ¥æ‹¼æ¥, ç„¶åé‚£ä¸ª `while stack and stack[-1].isdigit():` , è¿™ä¸ªåœ°æ–¹å¾ˆè€äººå¯»å‘³, ä½ é¡ºåºåä¸€ä¸‹æ˜¯ä¼šæŠ¥ list index out of range è¿™ä¸ªé”™çš„, çœ‹èµ·æ¥è¿˜æ˜¯æœ‰å…ˆåæ‰§è¡Œçš„é¡ºåºé€»è¾‘, ç„¶åè¿™ä¸ªstack å¾ˆå®¹æ˜“å¿˜æ‰, å› ä¸ºæ•°å­—å¾€å‰èµ°å¾ˆå¯èƒ½ç›´æ¥ç©ºäº†, æ²¡ä¸œè¥¿äº†, æ‰€ä»¥è¦åŠ ä¸ªstack æœ¬èº«æ˜¯å¦æ˜¯ç©ºçš„åˆ¤æ–­
    
    ```python
    class Solution:
        def decodeString(self, s: str) -> str:
            stack = []
            for i in s:
                if i != "]":
                    stack.append(i)
                else:
                    word = []
                    while stack[-1]!="[":
                        word = list(stack[-1]) + word
                        stack.pop()
                    # è¿™é‡Œçš„è¿™ä¸ªstack.pop()å¾ˆå®¹æ˜“å¿˜
                    stack.pop()
    
                    num = ""
                    while stack and stack[-1].isdigit():
                        num = stack[-1] + num
                        stack.pop()
    
                    
                    num = int(num)
    
                    stack = stack + num * word
    
            
            # è¿™é‡Œä¸€åº¦å†™å‡º return str(stack)
            return ''.join(stack)
    ```
    

---

## 3.13 (æ¯æ—¥æ¸©åº¦)

- `stack.pop()` æ˜¯ä¸€ä¸ªåŒæ—¶å…·æœ‰è¿”å›å€¼å’Œå‰¯ä½œç”¨çš„æ“ä½œï¼šå®ƒè¿”å›æ ˆé¡¶å…ƒç´ çš„å€¼ï¼Œå¹¶ä¸”ä¿®æ”¹äº†åŸæ ˆçš„ç»“æ„
- å¦‚æœä½ æƒ³è¦åŒæ—¶éå†æ•°ç»„çš„ä¸‹æ ‡å’Œå†…å®¹ï¼Œå¯ä»¥ä½¿ç”¨ `enumerate()` å‡½æ•°ã€‚`enumerate()` å‡½æ•°ä¼šè¿”å›ä¸€ä¸ªæšä¸¾å¯¹è±¡ï¼Œå…¶ä¸­æ¯ä¸ªå…ƒç´ æ˜¯ä¸€ä¸ªå…ƒç»„ï¼ŒåŒ…å«ä¸€ä¸ªè®¡æ•°å™¨ï¼ˆä¸‹æ ‡ï¼‰å’Œä¸€ä¸ªå¯¹åº”çš„æ•°ç»„å…ƒç´ 
- æ¯æ—¥æ¸©åº¦, ç»´æŠ¤ä¸€ä¸ªå•è°ƒæ ˆ, åªé€’å‡, æœ‰å¤§çš„è¿›æ¥, å°±ä¸€ä¸ªä¸ªæŠŠæ¯”å®ƒå°çš„å‡ºæ ˆ; åœ¨å•è°ƒæ ˆåŸºç¡€é¢˜ä¸­ï¼Œç»å¸¸éœ€è¦ç±»ä¼¼è¿™ç§çš„è§£é¢˜æ€è·¯ï¼šåœ¨Â *O*(*n*)Â çš„æ—¶é—´å¤æ‚åº¦å†…æ±‚å‡ºæ•°ç»„ä¸­å„ä¸ªå…ƒç´ å³ä¾§ç¬¬ä¸€ä¸ªæ›´å¤§çš„å…ƒç´ åŠå…¶ä¸‹æ ‡ï¼Œç„¶åä¸€å¹¶å¾—åˆ°å…¶ä»–ä¿¡æ¯;   ç„¶å, æˆ‘ç–‘æƒ‘äº†å¾ˆä¹…ä¸ºä»€ä¹ˆè¿™ä¸ªå†…å±‚å¾ªç¯çš„æ—¶é—´å¤æ‚åº¦ä¸¥æ ¼éµè¡Œ, O(n)æ¬¡, å¯¹äºæ¯ä¸ªå…ƒç´ , 
æ¯æ¬¡å‡ºæ ˆçš„æ—¶å€™, éƒ½ä¸€å®šæ˜¯æ ˆé¡¶, è¯´ç™½äº†ä¸åœ¨æ ˆé¡¶ä¸è¢«æ¯”è¾ƒ, å°±ç®—åœ¨æ ˆé¡¶è¢«æ¯”è¾ƒæ²¡åŠæ³•å‡ºæ ˆ, è¿™ä¸ªæ—¶é—´æ˜¯å¦å¤–ä¸€ä¸ªå…ƒç´ ç”¨æ¥å…¥æ ˆçš„æ—¶é—´;
å…¥æ ˆ, æˆ‘ä»¬çŸ¥é“å…¥æ ˆå¯èƒ½éœ€è¦æ¯”è¾ƒå¾ˆå¤šæ¬¡, æ‰èƒ½æ‰¾åˆ°å…¥æ ˆçš„ä½ç½®, ç¡®å®šå…¥æ ˆäº†, å°±æ˜¯ç®—ä½œè‡ªå·±çš„æ—¶é—´, ç®—1; æ²¡æ‰¾åˆ°å…¥æ ˆ, é‚£å°±æ˜¯å½“å‰æ ˆé¡¶éœ€è¦å‡ºæ ˆ, ç®—ä½œåˆ«äººå‡ºæ ˆçš„æ—¶é—´;

æˆ‘ä¹‹å‰æƒ³ä¸é€šçš„å°±æ˜¯, å¯¹äºæ¯ä¸ªå…ƒç´ å®ƒå¯èƒ½éœ€è¦æ¯”è¾ƒå¾ˆå¤šæ¬¡æ‰å¯ä»¥å…¥æ ˆ, å…¥æ ˆå, æ¯”è¾ƒå¾ˆå¤šæ¬¡æ‰å¯ä»¥å‡ºæ ˆ, ç°åœ¨æˆ‘ç†è§£äº†: å…¥ä¸äº†æ ˆæ—¶å€™çš„æ¯”è¾ƒ â†’ åˆ«äººå‡ºæ ˆä¸€æ¬¡å˜›, ä¸ç®—æˆ‘è‡ªå·±; å‡ºä¸äº†æ ˆ â†’ æ¯ä¸ªä¸åŒæ–°äººçš„å…¥æ ˆä¸€æ¬¡å˜›

åœ¨è¿™ä¿©ä¸­æ—¶é—´æƒ…å†µä¸‹, æˆ‘ä»¬å¯ä»¥å‘ç°, å¯¹äºæ¯ä¸ªå…ƒç´ , å…¥æ ˆä¸€æ¬¡å¸¸æ•°æ—¶é—´, å‡ºæ ˆä¸€æ¬¡å¸¸æ•°æ—¶é—´. (è¿™å°±æ˜¯å•è°ƒæ ˆ æ—¶é—´å¤æ‚åº¦çš„é­…åŠ›?)
    
    ```python
    class Solution:
        def dailyTemperatures(self, temperatures: List[int]) -> List[int]:
            stack =[]
            day = [0] * len(temperatures) 
            # stack.append(temperatures[0])
            # day = [0]
            # æœ€å¼€å§‹å¯ä»¥ç”¨ while stack æ¥ä»£æ›¿äº†å¢åŠ çš„è¿‡ç¨‹
            for i, value in enumerate(temperatures):
    		        # è¿˜æ˜¯ stack è¦å†™åœ¨while çš„æœ€å‰é¢
                while stack and value > temperatures[stack[-1]]:
    		            # æ¯”æ ˆé¡¶å¤§, æ ˆé¡¶å‡ºæ ˆ, è®¡ç®—é¢˜ç›®è¦æ±‚çš„å¤©æ•°
                    j = stack.pop()
                    # ç¬¬å‡ å¤© - ç¬¬å‡ å¤©, ä¹Ÿå°±æ˜¯åœ¨ç¬¬å‡ å¤©å, ç¬¬ä¸€æ¬¡å‡ºç°æ¸©åº¦å‡é«˜
                    day[j] = i-j
                # å•è°ƒæ ˆè®°å½•çš„æ˜¯, ç¬¬å‡ å¤©(ä¸‹æ ‡)
                stack.append(i)
        
            return day
    ```
    

---

## 3.14 (å¼€å§‹é“¾è¡¨, çœ‹äº†ä¸‹ç›¸äº¤é“¾è¡¨çš„é¢˜è§£)

- é¢˜è§£çš„æ€è·¯ç¡®å®ç‰›é€¼, ä¿©æ¡ä¸åŒé•¿çš„, èµ° a+b+c çš„é•¿åº¦ä¸€å®šèƒ½æ‰¾åˆ°ç›¸äº¤ç‚¹; æ²¡æ‰¾åˆ°å°±æ˜¯ä¿©ä¸ªæŒ‡é’ˆéƒ½æ˜¯None

## 3.15 (æ­å·happy, æ²¡åˆ·)

## 3.16 (ç©å®Œå›å­¦æ ¡å¤ªç´¯äº†, æ²¡åˆ·)

---

## 3.17 (ç›¸äº¤é“¾è¡¨)

- çœ‹leetcode, ä¸€ç›´æ²¡çœ‹æ‡‚ä¸ºä»€ä¹ˆé“¾è¡¨çš„å®šä¹‰åˆ°åº•å…·ä½“æ˜¯æ€ä¹ˆæ ·çš„; ç›´åˆ°çœ‹åˆ°è¯„è®ºåŒºçš„ä¸€ä¸ªcomment: è¿™æ˜¯é¢˜ç›®åˆå§‹åŒ–é“¾è¡¨çš„æ–¹å¼ï¼Œéš¾ç‚¹å°±æ˜¯è¿™ä¸ªï¼Œåˆ«çº ç»“åˆå§‹åŒ–é“¾è¡¨åçš„å†…å­˜åœ°å€ç›¸ç­‰ï¼Œé¢˜ç›®çš„æ„æ€æ˜¯åˆå§‹åŒ–çš„æ—¶å€™å°±å·²ç»åˆ†é…å¥½äº†å†…å­˜åœ°å€
    
    ```cpp
    package hot100;
    
    public class GetIntersectionNodeTest {
    
       public static class ListNode {
           int val;
           ListNode next;
    
           ListNode(int x) {
               val = x;
               next = null;
           }
       }
    
       public static void main(String[] args) {
           ListNode l1 = new ListNode(4);
           ListNode la = new ListNode(1);
           ListNode lb = new ListNode(8);
           ListNode lc = new ListNode(4);
           ListNode ld = new ListNode(5);
           l1.next = la;
           la.next = lb;
           lb.next = lc;
           lc.next = ld;
    
           ListNode l2 = new ListNode(5);
           ListNode le = new ListNode(6);
           ListNode lf = new ListNode(1);
           l2.next = le;
           le.next = lf;
           lf.next = lb;
    
           System.out.println(l1.next == l2.next.next); // 1  false
           System.out.println(l1.next.next == l2.next.next.next); // 8  true
       }
    }
    ```
    
- ç±»çš„å®ä¾‹åŒ–å¯¹è±¡çš„æ¯”è¾ƒæ˜¯ é€šè¿‡åœ°å€æ¥æ¯”è¾ƒçš„, è¯´ç™½äº†å°±æ˜¯æ˜¯ä¸æ˜¯ä¸€ä¸ªå®ä¾‹! Python ä¸­ï¼Œä»»ä½•å¯¹è±¡éƒ½å¯ä»¥åœ¨å¸ƒå°”å€¼ä¸Šä¸‹æ–‡ä¸­è¢«è¯„ä¼°ä¸º `True` æˆ– `False`ã€‚å…·ä½“æ¥è¯´ï¼šå¦‚æœ `A` æ˜¯ `None`ï¼ˆå³ç©ºå€¼ï¼‰ï¼Œé‚£ä¹ˆ `if A` çš„æ¡ä»¶åˆ¤æ–­ç»“æœä¸º `False`ã€‚å¦‚æœ `A` æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„å¯¹è±¡ï¼ˆå³ä¸æ˜¯ `None`ï¼‰ï¼Œé‚£ä¹ˆ `if A` çš„æ¡ä»¶åˆ¤æ–­ç»“æœä¸º `True`ã€‚
    
    ```python
    # Definition for singly-linked list.
    # class ListNode:
    #     def __init__(self, x):
    #         self.val = x
    #         self.next = None
    
    class Solution:
        def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> Optional[ListNode]:
            A = headA
            B = headB
            while A != B:
    		        # è¿™äº›A.next= ListNode(3)è¿™æ ·çš„éƒ½æ˜¯é¢˜ç›®ç³»ç»Ÿå·²ç»å†™å¥½äº†
                A = A.next if A else headB # è·³åˆ°headBåªä¼šè¿è¡Œä¸€æ¬¡, å› ä¸ºè·‘å®Œ
                # ä¿©ä¸ªé“¾éƒ½æ²¡ç›¸äº¤å°±æ˜¯ä¿©ä¸ªéƒ½æ˜¯Noneçš„æƒ…å†µäº†
                B = B.next if B else headA
            return A
    ```
    

---

## 3.18 (åè½¬é“¾è¡¨, è¿­ä»£)

- è¿­ä»£æ³•, ä»”ç»†æƒ³æƒ³ä¹Ÿä¸éš¾, æœ¬è´¨å°±æ˜¯æ”¹å˜æŒ‡é’ˆæŒ‡å‘, æ¯æ¬¡éƒ½æ˜¯æŒ‡ä¸Šä¸€ä¸ª, å¯¹äºæ¯ä¸ªèŠ‚ç‚¹, è¿›è¡Œ: æ”¹å˜æŒ‡é’ˆä¿¡æ¯ (æŒ‡å‘å‰ä¸€ä¸ª, è¿™ä¸ªä¿¡æ¯æ¥æºäºå“ªå‘¢)  åœ¨æ”¹å˜æŒ‡é’ˆä¿¡æ¯å‰, å­˜å‚¨åŸæœ¬æŒ‡é’ˆä¿¡æ¯(çŸ¥é“ä¸‹ä¸€ä¸ªæ‰¾è°, å»æŒ‡è‡ªå·±)  ç”±2å¾—å‡º, éœ€è¦å­˜å‚¨è‡ªå·±çš„ä½ç½®ä¿¡æ¯åˆ°ç»™ä¸‹ä¸€ä¸ªèŠ‚ç‚¹, è®©ä»–æŒ‡
    
    ```python
    # Definition for singly-linked list.
    # class ListNode:
    #     def __init__(self, val=0, next=None):
    #         self.val = val
    #         self.next = next
    class Solution:
        def reverseList(self, head: Optional[ListNode]) -> Optional[ListNode]:
            cur = head
            pre  = None
            while cur :
                # æˆ‘åŸæœ¬æŒ‡å‘è°
                xiayige = cur.next
                # key step, è¦åè½¬å°±æ˜¯æ”¹ç¼–æŒ‡çš„è°, æ”¹æˆæŒ‡ä¹‹å‰çš„
                cur.next = pre
                # æ€ä¹ˆæƒ³çš„å‘¢, emmm, ä¸€æ¬¡æ¬¡å¾€åçš„èŠ‚ç‚¹èµ°,
                # æ—¢ç„¶æ˜¯å¾ªç¯å¾€åéå†, è‚¯å®šæœ‰ä¸ªè¦ç”¨æ¥å­˜ä¹‹å‰çš„èŠ‚ç‚¹ä½ç½®
                # ä½¿å¾—ä¸‹ä¸€ä¸ªå¾ªç¯çš„cur.next = pre æœ‰ä¸œè¥¿
                pre = cur
                # ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å–½
                cur = xiayige 
            return pre # è¿™ä¸ªreturn pre ç¡®å®ç²¾é«“
    ```
    

---

## 3.19 (åè½¬é“¾è¡¨, é€’å½’)

- å¼ºè¡Œåˆ°C++, åˆ«å¿˜äº†ç»™æ¯è¡Œåé¢åŠ  `;`  ç›®å‰, ä¸çŸ¥é“å¦‚ä½•æƒ³åˆ°è¿™ä¸ªé€’å½’çš„æ–¹æ³•, å†è¯´å§
    
    ```cpp
    class Solution {
    public:
        ListNode* reverseList(ListNode* head) {
            if (!head || !head->next) {
                return head;
            }
            ListNode* newHead = reverseList(head->next);
            head->next->next = head;
            head->next = nullptr;
            return newHead;
        }
    };
    ```
    

---

## 3.20 (æ¯•è®¾, æ²¡åˆ·)

- åˆ·è§†é¢‘, å¼€åˆ°äº†é€’å½’, ä¸Šé¢é‚£ä¸ªåè½¬é“¾è¡¨çš„é€’å½’å’Œæ±‰è¯ºå¡”çš„é€’å½’

## 3.21 (æ¯•è®¾, æ²¡åˆ·)

---

## 3.22 (é“¾è¡¨çš„ä¸­é—´ç»“ç‚¹ & å›æ–‡é“¾è¡¨ & ç¯å½¢é“¾è¡¨)

- C++å¥½åƒåŒºåˆ† å¤§å°å†™, ä¸èƒ½å†™True, false
- é€»è¾‘ä¸ï¼ˆ`&&`ï¼‰ã€é€»è¾‘æˆ–ï¼ˆ`||`ï¼‰å’Œé€»è¾‘éï¼ˆ`!`ï¼‰
- **æŒ‡é’ˆçš„å£°æ˜**ï¼š
    - æŒ‡é’ˆçš„å£°æ˜æ ¼å¼ä¸ºï¼š`ç±»å‹å *æŒ‡é’ˆå˜é‡å;`
    - ä¾‹å¦‚ï¼š`int* p;` è¡¨ç¤ºå£°æ˜äº†ä¸€ä¸ªæŒ‡å‘ `int` ç±»å‹çš„æŒ‡é’ˆå˜é‡ `p`ã€‚
    - åœ¨å£°æ˜æŒ‡é’ˆæ—¶ï¼Œ æ˜¯æŒ‡é’ˆçš„æ ‡è¯†ç¬¦ï¼Œè¡¨ç¤ºè¿™æ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜é‡ã€‚
- C++å‡½æ•°çš„å®šä¹‰åŒ…æ‹¬ä»¥ä¸‹å‡ ä¸ªéƒ¨åˆ†ï¼š
    
    ```cpp
    è¿”å›ç±»å‹ å‡½æ•°å(å‚æ•°ç±»å‹1 å‚æ•°å1, å‚æ•°ç±»å‹2 å‚æ•°å2, ...) {
    // å‡½æ•°ä½“// å¯èƒ½åŒ…å«è¿”å›è¯­å¥
    }
    ```
    
    - **è¿”å›ç±»å‹**ï¼šå‡½æ•°æ‰§è¡Œå®Œæˆåè¿”å›çš„å€¼çš„ç±»å‹ã€‚å¦‚æœå‡½æ•°ä¸è¿”å›å€¼ï¼Œåˆ™ä½¿ç”¨`void`ã€‚
    - **å‡½æ•°å**ï¼šå‡½æ•°çš„åç§°ï¼Œç”¨äºæ ‡è¯†å‡½æ•°ã€‚
    - **å‚æ•°åˆ—è¡¨**ï¼šå‡½æ•°æ¥æ”¶çš„è¾“å…¥å‚æ•°ï¼Œå‚æ•°åˆ—è¡¨å¯ä»¥ä¸ºç©ºã€‚
    - **å‡½æ•°ä½“**ï¼šå‡½æ•°çš„å…·ä½“å®ç°ï¼ŒåŒ…å«ä¸€ç»„è¯­å¥ã€‚
- é“¾è¡¨çš„ä¸­é—´èŠ‚ç‚¹, å¿«æ…¢æŒ‡é’ˆ, slowèµ°ä¸€æ­¥, fast èµ°ä¿©æ­¥; å¦‚æœé“¾è¡¨é•¿åº¦æ˜¯å•æ•°, é‚£ä¹ˆå½“slowèµ°åˆ°æ­£ä¸­é—´, fast æ­£å¥½åˆ°æœ€åä¸€ä¸ªNode; é•¿åº¦æ˜¯å¶æ•°, æ­¤æ—¶å†èµ°ä¸€æ­¥,å°±æ˜¯slowåˆ°, åä¸€åŠçš„ç¬¬ä¸€ä¸ª, faståˆ°æœ€åä¸€ä¸ªNodeâ†’ next, è¯´ç™½äº†å°±æ˜¯null;
    
    ```cpp
    class Solution {
    public:
        ListNode* middleNode(ListNode* head) {
            ListNode* slow = head;
            ListNode* fast = head;
            while( fast && fast->next) 
            {
                slow = slow->next;
                fast = fast->next->next;  
            };
            return slow;
        }
    };
    ```
    
- æŒæ¡äº†ä¸­é—´èŠ‚ç‚¹å’Œåè½¬é“¾è¡¨, å°±å¯ä»¥å†™å›æ–‡é“¾è¡¨äº†; å†™ä¿©ä¸ªå‡½æ•°, ç„¶åæŒ‰ç…§çµç¥çš„é¢˜è§£, å†™å‡½æ•°çš„æ—¶å€™è®°å¾—, ä¼ å‚æ•°, è¦æ³¨æ˜ç±»å‹, è¿˜è¡Œæ‰‹æ’•äº†ä¸€æ³¢åè½¬é“¾è¡¨çš„æœ€åŸºç¡€çš„è§£æ³•; ç„¶åæ˜¯å›æ–‡é“¾è¡¨çš„æ€è·¯, å…ˆæ¢æµ‹ä¸­é—´ç»“ç‚¹, è¦ä¹ˆå•æ•°ä¸ªçš„æ­£å¥½ä¸­é—´ä½œä¸ºhead2, è¦ä¹ˆå¶æ•°ä¸ªçš„ååŠéƒ¨åˆ†çš„ç¬¬ä¸€ä¸ªä½œä¸ºhead2; ç„¶åå°±æ˜¯while(head2){}, å› ä¸ºhead2 é•¿åº¦æ˜¯è‚¯å®šå°äºhead, æ‰€ä»¥æˆ‘åªè¦æ¯”è¾ƒhead å’Œhead2 çš„val æ˜¯ä¸æ˜¯ä¸€æ ·, ç„¶åä¸€ä¸ªä¸ªæ¯”ä¸‹å»å°±å¥½äº†, if åªè¦å‡ºç°ä¸ä¸€æ ·å°±false, æ²¡æœ‰å°±æ˜¯æœ€å¤–å±‚çš„ç›´æ¥return true
    
    ```cpp
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    class Solution {
        ListNode* findmiddle(ListNode* head)
        {
            ListNode* slow = head;
            ListNode* fast = head;
            while(fast && fast->next){
                slow = slow -> next;
                fast = fast -> next -> next;
    
            }
            return  slow;
        }
        
    
        ListNode* reverse(ListNode* head){
            ListNode *pre = NULL;
            ListNode *cur = head;
            ListNode *mid = nullptr;
            while(cur){
                mid = cur ->next;
                cur -> next = pre;
                pre = cur;
                cur = mid;
            }
            return pre;
        }
    public:
        bool isPalindrome(ListNode* head) {
            ListNode* head1 = findmiddle(head);
            ListNode* head2 = reverse(head1);
            while(head2){
                if (head -> val != head2->val){
                    return false;
                }
                head = head->next;
                head2 = head2->next;
            }
            return true;
        }
    };
    ```
    
- ç¯å½¢é“¾è¡¨, æ€è·¯å°±æ˜¯å¿«æ…¢æŒ‡é’ˆ, æ³¨æ„å¦‚æœç»™çš„æµ‹è¯•ç”¨ä¾‹æ˜¯ç©º, è¦å•ç‹¬åˆ¤æ–­, ç¬¬ä¸€æ¬¡å†™çš„æ—¶å€™, æ²¡æƒ³åˆ°è¿™ç‚¹
    
    ```cpp
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode(int x) : val(x), next(NULL) {}
     * };
     */
    class Solution {
    public:
        bool hasCycle(ListNode *head) {
            if(head == NULL){
                return false;
            }
            ListNode* slow = head;
            ListNode* fast = head;
            while(fast->next && fast->next->next )
            {
                slow = slow->next;
                fast = fast->next->next;
                if (slow == fast)
                {
                    return true;
                }
            }
            return false;
        }
    };
    ```
    

---

## 3.23 (ç¯å½¢é“¾è¡¨2 & åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„)

- O(1)çš„æ—¶é—´å¤æ‚åº¦, éœ€è¦æ•°å­¦ä¸Šçš„ä¼˜åŒ–, è¯æ˜slowå’Œfastç›¸é‡å, headå’Œslowä¸€èµ·ç§»åŠ¨ä¸€å®šèƒ½åœ¨ç¯å½¢å…¥å£ç›¸é‡; æ­£å¸¸æ€è·¯æ˜¯slow è¾¹èµ°è¾¹ç”¨å“ˆå¸Œè¡¨è®°å½•éå†çš„èŠ‚ç‚¹, å‡ºç°é‡å¤çš„ç»“ç‚¹, return
å…¶ä»–æ²¡ä»€ä¹ˆé—®é¢˜, ä¸€ä¸ªæ˜¯ç©ºæŒ‡é’ˆè¦åˆ¤å®š, ç©ºæŒ‡é’ˆæ²¡æœ‰â€œæˆå‘˜â€, æ‰€ä»¥å°è¯•è®¿é—®è¿æ³•â€¦
å¦å¤–æœ‰ä¸ªæ˜¯å†™fast -> next && fast -> next -> next, ä¸è¦å†™åäº†!!!
    
    ```cpp
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode(int x) : val(x), next(NULL) {}
     * };
     */
    class Solution {
    public:
        ListNode *detectCycle(ListNode *head) {
            ListNode* slow = head;
            ListNode* fast = head;
            if(head == nullptr){
                return nullptr;
            }
            // while((fast -> next-> next) != nullptr){
            while(fast -> next && fast -> next -> next){
                slow = slow -> next;
                fast = fast -> next-> next;
                if (slow==fast){
                    while(head != slow){
                        head = head->next;
                        slow = slow-> next;
                    }
                    return slow;
                }
            }
            return nullptr;
        }
    };
    ```
    
- 88. åˆå¹¶ä¸¤ä¸ªæœ‰åºæ•°ç»„, å…¶å®æˆ‘æ˜¯æœ‰ç‚¹æ‡µçš„; æœ‰åºæ•°ç»„äºŒåˆ†æŸ¥æ‰¾å’ŒæŒ‡é’ˆ?  é€†å‘åŒæŒ‡é’ˆ, æ—¶é—´å¤æ‚åº¦O(m+n); ç„¶åæ˜¯ä¸€ä¸ª `nums1[p--] = nums1[p1--];`  å­¦äº†ä¸€ä¸ªè¿™ç§å†™æ³•, æ›´æ–°å†…å®¹åŒæ—¶æ›´æ–°æŒ‡é’ˆçš„ç´¢å¼•
    
    ```cpp
    class Solution {
    public:
        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
            int p = m+n-1;
            int p1 = m-1;
            int p2 = n-1;
            while(p2 >=0){
                if(p1>=0 && nums1[p1]>nums2[p2]){
                    nums1[p--] = nums1[p1--];
                }
                else{
                    nums1[p--] = nums2[p2--];
                }
            }
        }
    };
    ```
    
- åœ¨C++ä¸­ï¼Œé€»è¾‘è¿ç®—ç¬¦`&&`å…·æœ‰çŸ­è·¯æ±‚å€¼çš„ç‰¹æ€§ã€‚è¿™æ„å‘³ç€åœ¨è¡¨è¾¾å¼`A && B`ä¸­ï¼Œå¦‚æœ`A`ä¸º`false`ï¼Œåˆ™ä¸ä¼šè®¡ç®—`B`ï¼Œå› ä¸ºæ•´ä¸ªè¡¨è¾¾å¼çš„ç»“æœå·²ç»ç¡®å®šä¸º`false`åœ¨ä½ çš„æ¡ä»¶åˆ¤æ–­`fast->next && fast->next->next != nullptr`ä¸­ï¼Œ`fast->next`ä¼šå…ˆè¢«è®¡ç®—ã€‚
    
    å¦‚æœ`fast->next`ä¸º`false`ï¼ˆå³`fast->next`æ˜¯ç©ºæŒ‡é’ˆï¼‰ï¼Œåˆ™æ•´ä¸ªè¡¨è¾¾å¼çš„ç»“æœä¸º`false`ï¼Œå¹¶ä¸”ä¸ä¼šè®¡ç®—`fast->next->next != nullptr`éƒ¨åˆ†ã€‚å› æ­¤ï¼Œ`fast->next`çš„åˆ¤æ–­ä¼˜å…ˆäº`fast->next->next != nullptr`çš„åˆ¤æ–­ã€‚è¿™æ ·å¯ä»¥é¿å…åœ¨`fast->next`ä¸ºç©ºæŒ‡é’ˆæ—¶è®¿é—®`fast->next->next`å¯¼è‡´çš„ç©ºæŒ‡é’ˆè§£å¼•ç”¨é”™è¯¯ã€‚
    
- å¦‚æœ`fast`æœ¬èº«æ˜¯ç©ºæŒ‡é’ˆï¼Œæˆ–è€…`fast->next`æ˜¯ç©ºæŒ‡é’ˆï¼Œé‚£ä¹ˆ`fast->next->next`å°±ä¼šå°è¯•è®¿é—®ç©ºæŒ‡é’ˆçš„æˆå‘˜ï¼Œå¯¼è‡´è¿è¡Œæ—¶é”™è¯¯
- åœ¨C++ä¸­ï¼Œé€»è¾‘è¿ç®—ç¬¦`&&`çš„ä¼˜å…ˆçº§ä½äºæ¯”è¾ƒè¿ç®—ç¬¦`!=`
- å‘ƒ ç„¶å`while(fast -> next && fast -> next -> next != nullptr)` å¯ä»¥ç›´æ¥å†™æˆ `while(fast -> next && fast -> next -> next)`  `!=nullptr`  å°±å¯ä»¥çœç•¥äº†
- **`cur = nums2[p2--];`**: è¿™éƒ¨åˆ†è¡¨ç¤ºå°†`nums2`æ•°ç»„ä¸­ç´¢å¼•ä¸º`p2`çš„å…ƒç´ çš„å€¼èµ‹ç»™å˜é‡`cur`ï¼Œç„¶åå°†`p2`çš„å€¼å‡1

---

## 3.24 (åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨)

- è¿™é“é¢˜ç›®, èµ·ç å†™äº†ä¿©ä¸ªå°æ—¶, debugä¹ŸèŠ±äº†å¥½åŠæ—¶é—´â€¦ è‡ªå·±å†™çš„ä»£ç é€»è¾‘æ··ä¹±å•Š,éå¸¸çš„ä¸ä¼˜é›… ç¨å¾®æ€»ç»“ä¸‹å°±æ˜¯: æŠŠå¦å¤–ä¸€ä¸ªé“¾è¡¨å¡è¿›å¦ä¸€ä¸ªé“¾è¡¨, è¦å…ˆå¼„ä¸€ä¸ª`ListNode *tou = new ListNode();` å¤´çš„ç©ºæŒ‡å‘List2, åé¢æœ‰å¾ˆå¤šè¦åˆ¤æ–­çš„åˆ†æ”¯å’Œç»†èŠ‚å¤„ç†, æ€è·¯å¾ˆå¤æ‚, è¦æ€è€ƒçš„ç‚¹å¾ˆå¤š
    
    ```cpp
    class Solution {
    public:
        ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
            // ListNode* head1(nullptr, ListNode *list1);
            // ListNode* head2(nullptr, ListNode *list1);
            // pre1 = head1;
            // pre2 = head2;
            ListNode *tou = new ListNode();
            ListNode *cur;
            ListNode *ans;
            ListNode *a;
            tou ->next = list2;
            bu = tou;
            if (list2 == nullptr){
                return list1;
            }
            while(list1 && list2){
                if(list1->val >= list2-> val && list2->next == nullptr){
                    list2 -> next = list1;
                    return bu -> next;
                }else if (list1->val >= list2-> val && list1->val <= list2->next->val ){
                    // a = list1;
                    // list1 = list1->next;
                    // cur = list2->next;
                    // list2->next = a;
                    // a -> next = cur;
                    // list2 = list2 -> next;
                    // å°‘ç”¨ä¸€ä¸ªä¸­é—´å˜é‡
                    // å­˜è¦æ”¾è¿›å»çš„ç»“ç‚¹, list1å…ˆåŠ¨å®Œ
                    // å…ˆè®©å­˜å¥½çš„æŒ‡å‘åç»­çš„, åœ¨è®©å‰é¢æŒ‡å‘å­˜å¥½çš„, list2å†åŠ¨
                    a = list1;
                    list1 = list1->next;
                    a -> next = list2->next;
                    list2->next = a;
                    list2 = list2 -> next;
                    
                }else if(list1 -> val < list2-> val){
                // è¿™é‡Œä¸ç›´æ¥å†™ tou = list1, åŒºåˆ«åœ¨äº, tou ç›®å‰æŒ‡çš„æ˜¯ç©ºèŠ‚ç‚¹
                // ç©ºèŠ‚ç‚¹, åŒæ—¶ä¹Ÿè¢«æœ€åè¦è¾“å‡ºçš„ansæŒ‡ç€, èƒ½å¤Ÿæ‰¾åˆ°æ–°é“¾çš„head
                // ä¸åƒä¸‹é¢è¿™æ ·å†™, å°±ä¼šä¸¢å¤±headçš„ä½ç½®
                    tou->next = list1;
                    tou = tou-> next;
                    list1 = list1-> next;
                    tou-> next = list2;
                }
                else{
                    list2 = list2-> next;
                }
            }
            return ans->next;
        }
    };
    ```
    
- çœ‹ä¸‹, çµç¥çš„åšæ³•, ä¸æ˜¯æŠŠä¸€ä¸ªé“¾è¡¨æ’å…¥å¦ä¸€ä¸ª, è€Œæ˜¯é‡å¼€ä¸€ä¸ª, ä¸€ä¸ªä¸ªæ’åœ¨ç¬¬ä¸‰ä¸ª, ä¹Ÿä¸ä¼šç”¨åˆ°å¤šä½™çš„ç©ºé—´, å› ä¸ºéƒ½æ˜¯ç›´æ¥æ‹¿list1å’Œlist2 å·²æœ‰çš„é“¾è¡¨ç»“ç‚¹ä½ç½®ç›´æ¥ç”¨çš„;  ç›´æ¥å¼€ä¸ªå“¨å…µç»“ç‚¹, ç„¶åä¸€ä¸ªä¸ªå¾€åé¢åŠ å°±å®Œäº‹äº†â€¦ å…¶å®æˆ‘ä¸Šé¢çš„æ€è·¯å°±æ˜¯æ¯æ¬¡æ¥å®Œè¿˜æœ‰ä¸€å®šæŠŠlist2æ‹¼è¿›æ¥, å°±å¾ˆå¤šä½™, æ²¡å•¥å¿…è¦, çº¯å±ç»™è‡ªå·±å¢åŠ codeé‡å’Œæ€ç»´é‡.
    
    è®²å®Œæ€è·¯çš„é—®é¢˜, æ¥çœ‹çœ‹è¿™ä¸ªä»£ç 
    
    `ListNode dummy{}; 
     auto cur = &dummy;` auto è‡ªåŠ¨ä¸ºcur å¯»æ‰¾ç±»å‹, `&dummy` ä¼ çš„æ˜¯åœ°å€
    
    `ListNode *tou = new ListNode();` ç„¶åå°±æ˜¯è¿™ä¸ªnewçš„è¯­æ³•, è¿”å›çš„æ˜¯è¿™ä¸ªå¯¹è±¡çš„åœ°å€
    
    ```cpp
    class Solution {
    public:
        ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
            ListNode dummy{}; // ç”¨å“¨å…µèŠ‚ç‚¹ç®€åŒ–ä»£ç é€»è¾‘
            auto cur = &dummy; // cur æŒ‡å‘æ–°é“¾è¡¨çš„æœ«å°¾
            // åé¢ä¹Ÿä¼šå‘ç°, è™½ç„¶è¿™é‡Œæ˜¯ä¸€ä¸ªæŒ‡å‘ æ ˆå†…å­˜, ä½†æ˜¯å®é™…return çš„æ˜¯dummy.next,
            // æ˜¯dummyæŒ‡å‘çš„ä¸‹ä¸€ä¸ª, ä¹Ÿå°±æ˜¯è¦ä¹ˆlist1, è¦ä¹ˆlist2. å°±ä¸ä¼šæœ‰ä½œç”¨åŸŸçš„é—®é¢˜äº† 
            while (list1 && list2) {
                if (list1->val < list2->val) {
                    cur->next = list1; // æŠŠ list1 åŠ åˆ°æ–°é“¾è¡¨ä¸­
                    list1 = list1->next;
                } else { // æ³¨ï¼šç›¸ç­‰çš„æƒ…å†µåŠ å“ªä¸ªèŠ‚ç‚¹éƒ½æ˜¯å¯ä»¥çš„
                    cur->next = list2; // æŠŠ list2 åŠ åˆ°æ–°é“¾è¡¨ä¸­
                    list2 = list2->next;
                }
                cur = cur->next;
            }
            cur->next = list1 ? list1 : list2; // æ‹¼æ¥å‰©ä½™é“¾è¡¨
            return dummy.next;
        }
    };
    ```
    
- ä¸‰å…ƒè¿ç®—ç¬¦
`condition ? expr1 : expr2`
 eg. `cur->next = list1 ? list1 : list2;`  å¦‚æœ `list1` ä¸ä¸ºç©ºï¼ˆ`list1` ä¸º `true`ï¼‰ï¼Œåˆ™ `cur->next` è¢«èµ‹å€¼ä¸º `list1`  è¿™æ®µä»£ç é€šå¸¸å‡ºç°åœ¨åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨çš„ç®—æ³•ä¸­ã€‚åœ¨åˆå¹¶è¿‡ç¨‹ä¸­ï¼Œå½“å…¶ä¸­ä¸€ä¸ªé“¾è¡¨å·²ç»å®Œå…¨è¢«éå†å®Œï¼ˆå³ `list1` æˆ– `list2` ä¸ºç©ºï¼‰ï¼Œå‰©ä¸‹çš„éƒ¨åˆ†å¯ä»¥ç›´æ¥æ¥åˆ°æ–°é“¾è¡¨çš„æœ«å°¾ã€‚è¿™æ®µä»£ç çš„ä½œç”¨å°±æ˜¯å°†å‰©ä½™çš„é“¾è¡¨éƒ¨åˆ†æ¥åˆ°æ–°é“¾è¡¨çš„æœ«å°¾ã€‚
- åœ¨å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œ`ListNode()` å’Œ `ListNode{}` çš„è¡Œä¸ºæ˜¯ç›¸åŒçš„ï¼Œå°¤å…¶æ˜¯åœ¨æœ‰é»˜è®¤æ„é€ å‡½æ•°çš„æƒ…å†µä¸‹ã€‚ç„¶è€Œï¼Œ`ListNode{}` çš„è¯­æ³•æ›´ç°ä»£ï¼Œé¿å…äº†å‡½æ•°è°ƒç”¨çš„æ­§ä¹‰ï¼Œå¹¶ä¸”åœ¨èšåˆåˆå§‹åŒ–æ—¶æ›´çµæ´»ã€‚å› æ­¤ï¼Œæ¨èä½¿ç”¨ `ListNode{}` çš„å†™æ³•ã€‚
- **`ListNode dummy{}; auto cur = &dummy;` èƒ½å†™æˆ `ListNode *cur = &dummy;` å—?**
    
    **å¯ä»¥**ï¼Œè¿™ä¸¤ç§å†™æ³•åœ¨åŠŸèƒ½ä¸Šæ˜¯ç­‰ä»·çš„ã€‚
    
    - `ListNode dummy{};` å®šä¹‰äº†ä¸€ä¸ª `ListNode` ç±»å‹çš„å¯¹è±¡ `dummy`ï¼Œå¹¶ä½¿ç”¨é»˜è®¤åˆå§‹åŒ–ã€‚
    - `auto cur = &dummy;` ä¸­ï¼Œ`auto` å…³é”®å­—ä¼šæ ¹æ®åˆå§‹åŒ–è¡¨è¾¾å¼çš„ç±»å‹æ¥æ¨æ–­å˜é‡çš„ç±»å‹ã€‚åœ¨è¿™é‡Œï¼Œ`&dummy` æ˜¯ `dummy` å¯¹è±¡çš„åœ°å€ï¼Œå…¶ç±»å‹æ˜¯ `ListNode*`ï¼ˆæŒ‡å‘ `ListNode` ç±»å‹çš„æŒ‡é’ˆï¼‰ã€‚å› æ­¤ï¼Œ`cur` è¢«æ¨æ–­ä¸º `ListNode*` ç±»å‹ã€‚
    - ç›´æ¥å†™æˆ `ListNode *cur = &dummy;` æ˜ç¡®åœ°å£°æ˜äº†ä¸€ä¸ªæŒ‡å‘ `ListNode` çš„æŒ‡é’ˆå˜é‡ `cur`ï¼Œå¹¶å°†å…¶åˆå§‹åŒ–ä¸º `dummy` çš„åœ°å€ã€‚è¿™ä¸¤ç§å†™æ³•åœ¨ç”Ÿæˆçš„æœºå™¨ä»£ç å’ŒåŠŸèƒ½ä¸Šæ˜¯å®Œå…¨ç›¸åŒçš„ã€‚
- **`ListNode *cur = &ListNode();` å¯ä¸å¯ä»¥ï¼ŒåŸå› æ˜¯ä»€ä¹ˆ?**
    
    **ä¸å¯ä»¥**ï¼Œè¿™ç§å†™æ³•ä¼šå¯¼è‡´ä¸´æ—¶å¯¹è±¡çš„ç”Ÿå‘½å‘¨æœŸé—®é¢˜ã€‚
    
    - `ListNode()` ä¼šåˆ›å»ºä¸€ä¸ªä¸´æ—¶çš„ `ListNode` å¯¹è±¡ã€‚è¿™ä¸ªä¸´æ—¶å¯¹è±¡åœ¨è¡¨è¾¾å¼ç»“æŸæ—¶ï¼ˆå³åˆ†å· `;` å¤„ï¼‰å°±ä¼šè¢«é”€æ¯ã€‚
    - `&ListNode()` å–å¾—çš„æ˜¯è¿™ä¸ªä¸´æ—¶å¯¹è±¡çš„åœ°å€ï¼Œå°†å…¶èµ‹å€¼ç»™æŒ‡é’ˆ `cur`ã€‚ç„¶è€Œï¼Œå½“è¿™è¡Œä»£ç æ‰§è¡Œå®Œæ¯•åï¼Œä¸´æ—¶å¯¹è±¡å·²ç»è¢«é”€æ¯ï¼Œ`cur` æˆä¸ºäº†ä¸€ä¸ªæ‚¬ç©ºæŒ‡é’ˆï¼ˆdangling pointerï¼‰ï¼ŒæŒ‡å‘ä¸€ä¸ªå·²ç»ä¸å­˜åœ¨çš„å¯¹è±¡ã€‚
    - åç»­å¦‚æœä½¿ç”¨è¿™ä¸ªæ‚¬ç©ºæŒ‡é’ˆ `cur`ï¼ˆæ¯”å¦‚è§£å¼•ç”¨å®ƒï¼‰ï¼Œä¼šå¯¼è‡´æœªå®šä¹‰è¡Œä¸ºï¼ˆUndefined Behaviorï¼‰ï¼Œå¯èƒ½ä¼šç¨‹åºå´©æºƒæˆ–è¯»å–åˆ°é”™è¯¯çš„æ•°æ®ã€‚
    
    å› æ­¤ï¼Œ`ListNode *cur = &ListNode();` æ˜¯ä¸æ­£ç¡®çš„å†™æ³•ï¼Œåº”è¯¥é¿å…
    
- æ ˆå†…å­˜å’Œå †å†…å­˜
    
    ![image.png](Leetcode%20%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0%201adca7bc3d8b802b8c04c13a85aa55d9/image.png)
    
- åœ¨ `ListNode *tou = new ListNode();` ä¸­ï¼Œ`new` è¿ç®—ç¬¦ç”¨äºåŠ¨æ€åˆ†é…å†…å­˜ï¼Œåˆ›å»ºçš„å¯¹è±¡ä¸æ˜¯ä¸´æ—¶å¯¹è±¡ã€‚
    
    **å…³é”®åŒºåˆ«:**
    
    - **ä¸´æ—¶å¯¹è±¡ï¼ˆå¦‚ `ListNode()` æˆ– `ListNode{}`ï¼‰**è¿™äº›å¯¹è±¡æ˜¯åœ¨æ ˆä¸Šåˆ†é…çš„ï¼Œå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸä»…é™äºå…¶æ‰€åœ¨çš„ä½œç”¨åŸŸã€‚å½“ä»£ç æ‰§è¡Œåˆ°åˆ†å· `;` æ—¶ï¼Œä¸´æ—¶å¯¹è±¡ä¼šè¢«é”€æ¯ã€‚
    - **ç”¨ `new` åˆ›å»ºçš„å¯¹è±¡**è¿™äº›å¯¹è±¡æ˜¯åœ¨å †ä¸Šåˆ†é…çš„ï¼Œå®ƒä»¬çš„ç”Ÿå‘½å‘¨æœŸä¸å—ä½œç”¨åŸŸé™åˆ¶ã€‚åªæœ‰å½“ä½ æ˜¾å¼è°ƒç”¨ `delete` æ—¶ï¼Œå¯¹è±¡æ‰ä¼šè¢«é”€æ¯ã€‚
- æ ˆä¸­çš„åŸºæœ¬ç±»å‹
    
    ```cpp
    void example() {
        int a = 42;      // a çš„å€¼ 42 ç›´æ¥å­˜å‚¨åœ¨æ ˆä¸­
        float b = 3.14f;  // b çš„å€¼ 3.14 ç›´æ¥å­˜å‚¨åœ¨æ ˆä¸­
    } // a å’Œ b åœ¨æ­¤å¤„è¢«è‡ªåŠ¨é‡Šæ”¾
    ```
    
- **å †ä¸­çš„åŸºæœ¬ç±»å‹**
    
    ```cpp
    void example() {
        int* p = new int(42);    // å †å†…å­˜åˆ†é…ï¼Œå­˜å‚¨ 42
        float* q = new float(3.14f);  // å †å†…å­˜åˆ†é…ï¼Œå­˜å‚¨ 3.14
        // ...
        delete p;  // å¿…é¡»æ‰‹åŠ¨é‡Šæ”¾
        delete q;
    }
    ```
    
- åœ¨ `ListNode *cur = head;` ä¸­ï¼Œ`cur` æ˜¯ä¸€ä¸ªæŒ‡é’ˆå˜é‡ï¼Œå®ƒæœ¬èº«å­˜å‚¨åœ¨æ ˆå†…å­˜ä¸­ï¼Œä½†å®ƒæŒ‡å‘çš„å¯¹è±¡å¯èƒ½åœ¨å †å†…å­˜æˆ–æ ˆå†…å­˜ä¸­ï¼Œå…·ä½“å–å†³äº `head` çš„å®šä¹‰ã€‚
    
    ### **1.Â `cur`Â æŒ‡é’ˆå˜é‡æœ¬èº«**
    
    - `cur` æ˜¯ä¸€ä¸ªå±€éƒ¨å˜é‡ï¼Œå­˜å‚¨åœ¨æ ˆå†…å­˜ä¸­ã€‚
    - å®ƒçš„ä½œç”¨æ˜¯ä¿å­˜ä¸€ä¸ªåœ°å€ï¼ˆå³å®ƒæŒ‡å‘çš„å¯¹è±¡çš„å†…å­˜åœ°å€ï¼‰ã€‚
    
    ### **2.Â `cur`Â æŒ‡å‘çš„å¯¹è±¡**
    
    `cur` æŒ‡å‘çš„å¯¹è±¡çš„å†…å­˜æ€§è´¨å–å†³äº `head` çš„å®šä¹‰ï¼š
    
    ### **æƒ…å†µ 1ï¼š`head`Â æŒ‡å‘å †å†…å­˜**
    
    å¦‚æœ `head` æ˜¯é€šè¿‡ `new` åŠ¨æ€åˆ†é…çš„å†…å­˜ï¼Œé‚£ä¹ˆ `cur` æŒ‡å‘çš„å¯¹è±¡åœ¨å †å†…å­˜ä¸­ã€‚ä¾‹å¦‚ï¼š
    
    ```cpp
    ListNode *head = new ListNode(); *// head æŒ‡å‘å †å†…å­˜*
    ListNode *cur = head;            *// cur ä¹ŸæŒ‡å‘å †å†…å­˜*
    ```
    
    åœ¨è¿™ç§æƒ…å†µä¸‹ï¼š
    
    - `head` å’Œ `cur` éƒ½æ˜¯æ ˆå˜é‡ï¼ˆå­˜å‚¨åœ¨æ ˆå†…å­˜ä¸­ï¼‰ã€‚
    - å®ƒä»¬ä¿å­˜çš„åœ°å€æŒ‡å‘å †å†…å­˜ä¸­çš„ `ListNode` å¯¹è±¡ã€‚
    
    ### **æƒ…å†µ 2ï¼š`head`Â æŒ‡å‘æ ˆå†…å­˜**
    
    å¦‚æœ `head` æŒ‡å‘çš„æ˜¯æ ˆä¸Šçš„å¯¹è±¡ï¼Œé‚£ä¹ˆ `cur` æŒ‡å‘çš„å¯¹è±¡ä¹Ÿåœ¨æ ˆå†…å­˜ä¸­ã€‚ä¾‹å¦‚ï¼š
    
    ```cpp
    ListNode head;        *// head æ˜¯æ ˆå˜é‡*
    ListNode *cur = &head; *// cur æŒ‡å‘æ ˆå†…å­˜*
    ```
    
    åœ¨è¿™ç§æƒ…å†µä¸‹ï¼š
    
    - `head` æ˜¯ä¸€ä¸ªæ ˆå˜é‡ã€‚
    - `cur` æ˜¯ä¸€ä¸ªæ ˆå˜é‡ï¼Œä¿å­˜äº† `head` çš„åœ°å€ã€‚
    
    ### **æ€»ç»“**
    
    - `cur` æŒ‡é’ˆå˜é‡æœ¬èº«å­˜å‚¨åœ¨æ ˆå†…å­˜ä¸­ã€‚
    - `cur` æŒ‡å‘çš„å¯¹è±¡å¯èƒ½åœ¨å †å†…å­˜æˆ–æ ˆå†…å­˜ä¸­ï¼Œå…·ä½“å–å†³äº `head` çš„å®šä¹‰ã€‚

---

## 3.25(ä¿©æ•°ç›¸åŠ )

- åœ¨C++ä¸­ï¼Œæ•´æ•°å‹å˜é‡åœ¨å¸ƒå°”åˆ¤æ–­ä¸­ä¼šè¢«éšå¼è½¬æ¢ä¸ºå¸ƒå°”å€¼ï¼Œåˆ¤æ–­ä¾æ®æ˜¯å€¼æ˜¯å¦ä¸ºé›¶.
- å…ˆæ¥çœ‹çœ‹æˆ‘ä»¬é‡åˆ°çš„é—®é¢˜ (å›°æ‰°äº†æˆ‘å¾ˆä¹…çš„é—®é¢˜)
    
    ```cpp
    // ä¸è¡Œçš„
    ListNode end;
    end = ListNode(1); 
    l1 -> next = &end; 
    
    return head; ä¹‹åå‡ºäº†è¿™ä¸ªå‡½æ•°ä½œç”¨åŸŸ, å¤–é¢æ‹¿è¿‡æ¥, æŒ‡é’ˆæŒ‡çš„å°±æ˜¯æ‚¬ç©ºæŒ‡é’ˆ
    
    // å¯è¡Œçš„, æ¨èä»¥åè¦åˆ›ä¸€ä¸ªç©ºèŠ‚ç‚¹, å¹¶æŒ‡å‘å®ƒçš„è¯, å°±æŒ‰ç…§è¿™æ ·å†™
    ListNode* end = new ListNode(1);
    l1 -> next = end;
    // ok
    cur = cur->next = new ListNode(carry % 10);
    ```
    
- æ¥çœ‹ä¸‹æˆ‘çš„æ„šè ¢ä»£ç , åªèƒ½è¯´æ—¶é—´å¤æ‚åº¦å’Œç©ºé—´å¤æ‚åº¦éƒ½æ‹‰æ»¡äº†; å…·ä½“æ€è·¯æ˜¯: ä¸€ç›´çœ‹l1, é»˜è®¤l1æ¯”l2 é•¿, å¦‚æœå‘ç° ä¸€æ ·é•¿,å°±çœ‹æœ€åè¦ä¸è¦è¿›ä½ç½®; æˆ–è€…çŸ­, å°±æŠŠl1 çš„next æŒ‡åˆ° l2 çš„next å†æ‰§è¡Œ `l1 = l1->next;`   å°±æ˜¯ä¸€å®šè¦æ³¨æ„çš„æ˜¯, å› ä¸ºæˆ‘ä»¬æœ€åè¿”å›çš„æ˜¯ä¸€ä¸ªé“¾è¡¨, è¿™ä¸ªé“¾è¡¨æ˜¯ä¸€ä¸ªæ¥ä¸€ä¸ªçš„è¿èµ·æ¥çš„, æ‰€ä»¥æˆ‘ä»¬è¦ç¡®ä¿, æ¯ä¸ªlistnode æœ¬èº«çš„next æ˜¯è¿åœ¨ä¸€èµ·çš„; åœ¨ä¿®æ”¹ä¹‹å‰æˆ‘æ˜¯ åˆ¤æ–­å®Œ ä¿©ä¸ªé“¾è¡¨çš„é•¿åº¦ä»¥åŠåé¢æœ‰æ²¡æœ‰nullptr, ç›´æ¥å°±å…ˆ`l1 = l1->next;`, è¿™ä¸ªæ—¶å€™å†äº¤æ¢ä»–ä»¬æ‰€æŒ‡çš„ä½ç½®, å°±å®Œè›‹äº†, å› ä¸ºå‰é¢é‚£ä¸ªl1 é“¾çš„ç‚¹è¿˜æ˜¯æŒ‡ç€ç©ºå•Š!!!ç­‰äºè¯´æ²¡æœ‰æŠŠl1 é“¾åˆ°l2 ä¸Š, è™½ç„¶code é‡Œæœ‰ç€æ“ä½œ, ä½†æ˜¯æƒ³æƒ³å°±çŸ¥é“ä¸å¯¹äº†
    
    ```cpp
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    class Solution {
    public:
        ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
            int carry=0;
            ListNode* head = l1;
            ListNode* cur;
            // ListNode end; // å£°æ˜ä¸ºé™æ€å˜é‡
            //end = ListNode(1); 
            ListNode* end = new ListNode(1);
            while(l1){
                if(l2){
                    if(l1 -> val + l2 -> val +carry>=10){
                        l1 -> val = l1 -> val + l2 -> val +carry -10;
                        carry = 1;
                    }else{
                        l1 -> val = l1 -> val + l2 -> val+carry;
                        carry = 0;
                    }
                    if(l1->next == nullptr && l2 ->next){
                        cur = l1-> next;
                        l1-> next = l2->next;
                        l2->next = cur;
                    }
                    if(l1->next == nullptr && l2 ->next ==nullptr && carry==1){
                        l1 -> next = end;
                        return head;
                    }
                    l1 = l1->next;
                    l2 = l2-> next;
                }else{
                    if(l1->val+ carry == 10){
                        l1->val = 0;
                        carry=1;
    
                    }else{
                        l1->val = l1->val+carry;
                        carry = 0;
                    }
                    if(l1->next == nullptr && carry==1){
                        l1 -> next = end;
                        return head;
                    }
                    l1 =l1-> next;
                }
    
            }
            return head;
        }
    };
    ```
    
- è¿™ä¸ªè§£å†³æ€è·¯å¥½, å†å¾ªç¯é‡Œå•ç‹¬çœ‹ l1 å’Œl2 ä»¥åŠæ˜¯å¦æœ‰è¿›ä½, è¿™æ ·å°±å¯ä»¥æ¥åˆ¤æ–­æ˜¯å¦éœ€è¦ä¸‹ä¸€ä¸ªæ–°å¼€çš„èŠ‚ç‚¹ æ¥å­˜å‚¨äº†, `if >= 10` çš„é€»è¾‘, ä¹Ÿå¯ä»¥ç”¨ `/= 10` ç›´æ¥æ›¿ä»£
    
    ```cpp
    class Solution {
    public:
        ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
            ListNode dummy; // å“¨å…µèŠ‚ç‚¹
            ListNode* cur = &dummy;
            int carry = 0; // è¿›ä½
            while (l1 || l2 || carry) { // æœ‰ä¸€ä¸ªä¸æ˜¯ç©ºèŠ‚ç‚¹ï¼Œæˆ–è€…è¿˜æœ‰è¿›ä½ï¼Œå°±ç»§ç»­è¿­ä»£
                if (l1) {
                    carry += l1->val; // èŠ‚ç‚¹å€¼å’Œè¿›ä½åŠ åœ¨ä¸€èµ·
                    l1 = l1->next; // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                }
                if (l2) {
                    carry += l2->val; // èŠ‚ç‚¹å€¼å’Œè¿›ä½åŠ åœ¨ä¸€èµ·
                    l2 = l2->next; // ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
                }  
                cur = cur->next = new ListNode(carry % 10); // æ¯ä¸ªèŠ‚ç‚¹ä¿å­˜ä¸€ä¸ªæ•°ä½
                carry /= 10; // æ–°çš„è¿›ä½, æ•´é™¤/
            }
            return dummy.next; // å“¨å…µèŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªèŠ‚ç‚¹å°±æ˜¯å¤´èŠ‚ç‚¹
        }
    };
    ```
    

---

## 3.26(åˆ é™¤é“¾è¡¨çš„å€’æ•°ç¬¬Nä¸ªç»“ç‚¹ & ä¸¤ä¸¤äº¤æ¢é“¾è¡¨çš„èŠ‚ç‚¹)

- é€’å½’è§£å†³çš„æ€è·¯, æœ‰ç‚¹åŠ
    
    ```cpp
    class Solution {
    public:
        int cur=0;
        ListNode* removeNthFromEnd(ListNode* head, int n) {
           if(!head) return NULL;
           head->next = removeNthFromEnd(head->next,n);
           cur++;
           if(n==cur) return head->next;
           return head;
        }
    };
    ```
    
- ç„¶åæ˜¯æ¯”è¾ƒå¤šçš„, çœ‹äº†çµç¥çš„è§£æ³•, å…¶ä»–è§£æ³•çœ‹åˆ°çš„æœ‰,åè½¬é“¾è¡¨ä¹‹åå†æ•°nä¸ª.   å¤ªä¹…æ²¡ç¢°Cè¯­è¨€äº†, æ²¡æƒ³åˆ°forå¾ªç¯çš„ k è¿˜æœ‰åœ¨å¤–é¢æå‰å®šä¹‰å¥½
å€¼å¾—æ³¨æ„çš„æ˜¯, å› ä¸ºæœ‰å¯èƒ½ä¼šåˆ é™¤å¤´ç»“ç‚¹, è€Œåˆ é™¤æŸä¸ªèŠ‚ç‚¹åˆéœ€è¦æŒ‡é’ˆå¤„åœ¨å®ƒçš„ä¸Šä¸ªç»“ç‚¹, æ‰€ä»¥æˆ‘ä»¬è€ƒè™‘å¯èƒ½ä¼šéœ€è¦åˆ é™¤å¤´ç»“ç‚¹, æ‰€ä»¥éœ€è¦å¼•å…¥dummy
    
    ```cpp
    /**
     * Definition for singly-linked list.
     * struct ListNode {
     *     int val;
     *     ListNode *next;
     *     ListNode() : val(0), next(nullptr) {}
     *     ListNode(int x) : val(x), next(nullptr) {}
     *     ListNode(int x, ListNode *next) : val(x), next(next) {}
     * };
     */
    class Solution {
    public:
        ListNode* removeNthFromEnd(ListNode* head, int n) {
            ListNode *dummy = new ListNode();
            dummy -> next = head;
            ListNode *i = dummy;
            ListNode *j = head;
            int k;
            for(k=2; k<=n; k++){
                j = j-> next;
            }
            while(j->next){
                i = i-> next;
                j = j-> next;
            }
            i -> next = i->next -> next;
            return dummy-> next;
            
    
        }
    };
    ```
    
- äº¤æ¢èŠ‚ç‚¹, ä¸€çœ¼é€’å½’, è¿™æ¬¡æ€»ç®—è‡ªå·±æ‘¸ç´¢å‡ºäº†ä¸€ä¸ªé€’å½’ç­”æ¡ˆ, ä¸€æ¬¡è¿‡!
1. æ‰¾é€’å½’ä»€ä¹ˆæ—¶å€™ç»ˆæ­¢
2. æˆ‘ä»¬è¦å…ˆæ˜ç¡®, è¿™ä¸ªé€’å½’åˆ°åº•è¦è¿”å›ä¸€ä¸ªä»€ä¹ˆä¸œè¥¿
3. æˆ‘ä»¬åªå…³æ³¨ä¸€æ¬¡è°ƒç”¨çš„å…·ä½“æ“ä½œ, è€Œä¸å»è¯¦ç»†åˆ†æåˆ°åº•å±‚å±‚æ€ä¹ˆå‘¼åº”(æˆ‘é€‰æ‹©æ”¾åœ¨æœ€åç”¨æ¡ˆä¾‹æ‰‹åŠ¨è·‘ä¸€æ¬¡)

æ˜æ˜¾, å½“é€’å½’åˆ°åªå‰©æœ€åä¸€ä¸ª,æˆ–è€…ç›´æ¥æŒ‡å‘ç©º, å°±è¦å¼€å§‹å¾€å›å¼¹å€¼äº†, ç„¶åæ¯”è¾ƒé‡è¦çš„point æ˜¯å“ªä¸€è¡Œé€’å½’è°ƒç”¨å…·ä½“æ˜¯æ€ä¹ˆå†™çš„code, è¯´ç™½äº†å°±æ˜¯ xxx= å‡½æ•°(yyy), æ‰¾åˆ°è¿™ä¸ªxxx å’Œyyyåº”è¯¥åˆ†åˆ«æ˜¯ä»€ä¹ˆ, åœ¨è¿™è¡Œä¸Šé¢æ˜¯é€€å‡ºæ¡ä»¶, è¿™è¡Œä¸‹é¢æ˜¯æ¯å±‚å‡½æ•°å…·ä½“è¦å¹²çš„äº‹æƒ…(é¡ºåºå†™å¾ªç¯è¦å¹²çš„äº‹) æ¨¡ç³Šçš„æ€è·¯å°±æ˜¯è¿™ä¸ª, ä¸è¦å¤ªæŠ ç»†èŠ‚, å…ˆæŠŠå¤§æ¦‚çš„å†™å‡ºæ¥, ç»†èŠ‚çš„èŠ‚ç‚¹, next head ä»€ä¹ˆçš„å¯ä»¥ç”¨é¡ºåºå†æƒ³
    
    ```cpp
    class Solution {
    public:
        ListNode* swapPairs(ListNode* head) {
            ListNode *cur;
            ListNode *newhead;
            if(head == nullptr){
                return nullptr;
            }else if(head -> next ==nullptr){
                return head;
            }
            // è¿™é‡Œè¿˜å¯ä»¥ä¼˜åŒ–æˆ
            // if(head == nullptr || head->next == nullptr){return head;}
            head -> next -> next = swapPairs(head->next -> next);
            newhead = head -> next;
            cur = head -> next -> next;
            head -> next -> next = head;
            head -> next = cur;
            return newhead;
        }
    };
    ```